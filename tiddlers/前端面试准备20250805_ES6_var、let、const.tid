created: 20250808105216991
modified: 20250808120052550
tags: 前端面试准备20250805/ES6
title: 前端面试准备20250805/ES6/var、let、const
type: text/vnd.tiddlywiki

!! var、let、const

!!! 概览（一句话版）

var、let、const 都是用来声明变量，但三者在作用域、提升（hoisting）与初始化时机、可重声明/可赋值性、与全局对象的关联、以及在循环/闭包/函数声明交互上的行为都不一样。理解这些差异的关键在于：var 是函数/全局级的“老式”声明，声明时会被初始化为 undefined；let/const 是块级的“词法”声明，存在“暂时性死区（TDZ）”，在到达初始化语句之前访问会抛出错误；const 还要求在声明时必须初始化且绑定不可被重赋值，但其指向的对象内容依然可变。

!!! var 的重要细节（行为、提升与兼容性）

* 作用域：在函数内部声明的变量具有局部作用域；在函数外声明的变量具有全局作用域。
* 声明提升：var 声明会在创建执行上下文时被“声明提升”（hoisted）并被初始化为 undefined，这意味着在声明之前引用该名字不会抛出引用错误，但值是 undefined。如果 var 与同名的函数声明同处一执行上下文，函数声明的绑定会先被建立（函数对象先可用），var 只是保证名字存在且初始为 undefined（后续的赋值依执行流发生）。
* 重复声明：var 允许在相同作用域内重复声明而不会报错，重复声明会被忽略（或等价于没有新声明）。
* 闭包陷阱：在 for 循环、if/else 等块内用 var 声明不会创建块级绑定；它们“越界”到外层函数/全局作用域，因此常见的闭包陷阱（用 var 的循环变量在闭包中最终都指向同一个绑定）正是由此产生。

示例（hoisting 与函数优先）：

```
console.log(typeof f); // "function"
function f(){ return 1; }
var f = 2;
console.log(typeof f); // "number"
```

示例（函数作用域，闭包陷阱）：

```
for (var i = 0; i < 3; i++) {
  setTimeout(()=> console.log(i), 0); // 三次都输出 3（同一个 i）
}
```

!!! let 的重要细节（块级、TDZ、不可重声明）

* let 提供块级作用域；在语句块（{}）开始处就为该名字创立了绑定，但这个绑定在实际执行到声明语句之前处于“未初始化”状态——也就是所谓的暂时性死区（Temporal Dead Zone, TDZ）。在 TDZ 内读取该名字会抛出 ReferenceError，typeof 对 TDZ 中的绑定也会抛出 ReferenceError（这点与对“未声明”的名字用 typeof 返回 "undefined" 不同，容易被误解）。
* let 不能在相同作用域重复声明（与 var 共存也会导致语法错误）；但在内层块可以声明同名的新绑定（遮蔽外层绑定）。
* let 在 for 循环头部与迭代语句中有“每次迭代创建新绑定”的规范语义（per-iteration binding），这就修复了 var 的闭包陷阱——每一次迭代的闭包捕获的是不同的循环绑定。

示例（TDZ）：

```
{
  // 这里访问 a 会抛 ReferenceError（TDZ）
  let a = 1; // TDZ 结束，从这里开始 a 已初始化
}
```

示例（for 循环每次迭代新绑定）：

```
for (let i = 0; i < 3; i++) {
  setTimeout(()=> console.log(i), 0); // 输出 0, 1, 2（每次迭代 i 是新的绑定）
}
```

!!! const 的重要细节（与 let 相同的词法特性 + 绑定不可改）

* const 与 let 一样是块级的、存在 TDZ、不能在同一作用域重复声明。
* const 额外的语义是声明时必须有初始值，并且该绑定在初始化后不能再被重赋值（再次赋值会抛出 TypeError）。必须注意 const 并不等同于“值不可变”；对于引用类型（对象、数组、函数），const 只是保证变量名绑定到同一个引用，引用指向对象的内部属性仍然可以修改，除非你另外使用 Object.freeze() 或类似手段。

示例（必须初始化且不可重赋值）：

```
const x = 1;
x = 2; // TypeError

const obj = {a:1};
obj.a = 2; // 合法，obj 指向的对象可变
```

示例（for 与 const）：

```
for (const k of [1,2,3]) {
  // 每次迭代 k 是新的 const 绑定，但在该迭代内部 k 不能被赋值
}
```

注意：在 for (const i=0; i<3; i++) 这种有递增赋值的 for-head 用法中会因尝试修改 const 绑定而出错；而 for..of/for..in 中每次迭代创建的是新的 const 绑定，循环能运行但在循环体内不能给它赋新值。

!!! 提升（hoisting）与 TDZ 的对比（精确到时机）

var 的名字在创建执行上下文阶段就被声明并被初始化为 undefined，因此“被提升”并且在声明之前可引用（值为 undefined）。函数声明（function declaration）在创建阶段提升的是整个函数对象，因此函数通常比 var 更“先可用”。let/const 的名字虽然在语法上也“被处理”以致在块开始就存在绑定，但它们处于未初始化状态直到执行流真正走到声明语句，访问时将抛 ReferenceError，这就是 TDZ。结论：var 的“hoisting”是把名字连同初始值 undefined 带上场，let/const 的“hoisting”只是把名字放进环境但不赋初始值。

!!! 重声明、重赋值与错误类型（语法阶段 vs 运行阶段）

如果在同一作用域重复用 let 或 const 声明同名变量，会在解析/编译阶段报 SyntaxError（静态错误）。用 var 重复声明则是允许的、不会报错（后声明不会影响原有绑定的初始化行为）。对已声明的 const 再赋值在运行时会抛 TypeError。在 TDZ 期间读取 let/const 会抛 ReferenceError；在 var 的情况下读取未被赋值的变量只会得到 undefined。

!!! 全局与模块环境的差别（脚本 vs 模块 vs Node）

在传统浏览器脚本环境，顶层 var 会在全局对象（window）上创建一个属性；顶层 let/const 不会在全局对象上创建属性（它们存在于全局词法环境里但不是 window 的自有属性）。在 ES 模块（type="module"）或 Node 的模块系统中，顶层声明都处于模块作用域，不再把名字挂到全局对象上；此外，模块的顶层 this 是 undefined。因此“顶层 var 一定成为全局对象属性”这个断言只对传统脚本（非模块）成立。不要把浏览器脚本的全局语义直接当作模块或 Node 环境的规则。

!!! 与函数声明/表达式、赋值函数的交互细节

函数声明在创建阶段被提升为整个函数对象；当函数以函数表达式形式并赋给 var 时，只有 var 名字被提前（值为 undefined），函数表达式的赋值发生在运行时。把函数表达式赋给 let/const，访问同名标识符在 TDZ 期间仍会抛 ReferenceError。把函数声明放入块中是历史上最容易引起混淆的点：非严格模式下为了兼容旧浏览器规范（Annex B 等），浏览器对块内函数声明的处理有特殊兼容行为；因此在块中声明函数建议改写为 let f = function(){} 或 const f = () => {}，以获得一致语义。

!!! 循环、闭包与“每次迭代绑定”的影响（典型陷阱与修复）

var 在循环中只有一个共享绑定，闭包捕获的是这个共享绑定，导致异步回调看到的是循环结束后的值。let / const 在 for/for..of/for..in 的每次迭代中会创建新的绑定（规范保证），因此闭包捕获的是每次迭代对应的那个绑定，程序行为更直观。对于需要在循环中为每次迭代保存当前值的场景，应使用 let（或 const）而不是 var。

示例（修复 var 问题的两种方式）：

```
// var 的问题
for (var i=0;i<3;i++){
  setTimeout(()=> console.log(i),0); // 3,3,3
}
// 用 let
for (let i=0;i<3;i++){
  setTimeout(()=> console.log(i),0); // 0,1,2
}
// 或用 IIFE（旧式修复）
for (var i=0;i<3;i++){
  (function(j){ setTimeout(()=> console.log(j),0); })(i); // 0,1,2
}
```

!!! 常见误区与容易出错的地方（面面俱到的注意点）

把 let/const 当作“严格版的 var”是错误的理解；let/const 是词法级别的声明，存在 TDZ，会在块开始就创建绑定但直到执行到声明行才初始化。不要依赖函数在块内的提升兼容性；不要混用 var 和 let/const 来试图“重声明”或覆盖外层绑定（这会在静态阶段报错或令人困惑）。不要以为 const 能冻结对象；const 只保护绑定本身。在跨环境（浏览器脚本、模块、Node）运行时注意顶层绑定和 this 的差异。typeof 在 TDZ 中会抛错误，而不是返回 "undefined"，因此用 typeof 检测是否存在名字在遇到 lexical 绑定时并不总是安全。最后，关于删除（delete）全局变量和属性、以及属性描述符（configurable/writable/enumerable）的具体细节，在不同宿主环境与脚本/模块模式下存在差别，不宜做一刀切的假设。

!!! 实战建议（工程化角度）

把 var 视为历史遗留，除非维护老代码或需要函数作用域特殊语义，否则优先使用 const，在需要重赋值的地方用 let。用 const 表达“引用不会被重指向”的意图，减少意外重赋值；用 let 表示“这个变量会变化”。在循环、异步回调、闭包场景默认使用 let/const 来避免 var 带来的典型陷阱。把函数写成函数表达式并用 const/let 绑定，可以避免函数提升带来的混乱（尤其在模块化代码中更清晰）。避免在块中写裸的函数声明（兼容性问题），除非非常明确目标运行环境的行为。

!!! 小结（快速记忆）

var：函数作用域＋提升并初始化为 undefined，可重复声明，容易越界到外层作用域，可能导致闭包陷阱。
let：块作用域＋存在 TDZ（在声明前访问会报错）＋不能重复声明，支持每次迭代新绑定（修复循环闭包问题）。
const：与 let 相同的词法特性，但声明时必须初始化且绑定不可被重赋值（对象内容仍可变）。
脚本顶层、模块顶层和 Node 模块的行为不同，函数声明在块中的历史兼容问题也要留意。工程上首选 const，需要变更时用 let，尽量避免 var。

如果你想，我可以把上面每个关键点配上更精确的代码示例与运行结果（逐行解释），或者把容易出错的 10 个真实世界 bug 场景逐一还原并讲解修复方案。

---

!!! 可以背诵的简洁版如下：

JavaScript 中 var、let、const 的区别在作用域、提升、初始化、重复声明、赋值规则和全局绑定上。var 具有函数作用域，声明会被提升并初始化为 undefined，可在同一作用域重复声明，块内声明会越界到外层，for 循环闭包易出错，顶层 var 会成为全局对象属性（非模块）。let 和 const 是块作用域，在块开始即创建绑定，但存在暂时性死区（TDZ），在声明前访问会抛 ReferenceError，不能在同一作用域重复声明；let 可多次赋值，const 声明时必须初始化且绑定不可改，引用类型值可变。let/const 在 for 循环中每次迭代都会创建新绑定，修复闭包陷阱；在模块或 Node 中，顶层声明不挂到全局对象上。工程实践中推荐默认用 const，需要变更才用 let，避免使用 var。

---

!!! 补充：暂时性死区

暂时性死区（TDZ, Temporal Dead Zone）

定义：

在代码块（{}）内，使用 let 或 const 声明的变量，从作用域开始到声明语句执行之前，这段区域称为“暂时性死区”。在这期间访问变量会报错（ReferenceError）