created: 20250810104409272
modified: 20250810142420491
tags: 前端面试准备20250805/Vue/组件间通信
title: 前端面试准备20250805/Vue/组件间通信/插槽
type: text/vnd.tiddlywiki

!!! 适用场景

---

一个template对应一个插槽

不带name 的template匹配默认插槽

带name 的匹配具名插槽

作用域插槽是特殊的具名插槽，可以通过在slot标签上类似于props的语法回传数据给父组件，父组件通过slot-scope、v-slot接收，添加样式和结构，然后放在 template 中传递给子组件去用。

Vue2 里你给插槽起名字是用 slot，想接收子组件给你的数据要用 slot-scope。

Vue3 把这两步合成了一步，用 v-slot:名字，既告诉 Vue 这是哪个插槽，也顺便把子组件传来的数据拿过来。默认插槽用 v-slot 就行。

子组件想把数据传给你，就直接写在 `<slot>` 里当“参数”给你，比如 `<slot :info="xxx">`，你在父组件用 v-slot 解构就能拿到这些数据。

---

一个组件会多次使用，但是又有少部分数据和结构会发生变化（当然可以用不同的子组件），那么就得通过父组件告诉子组件变化的内容是什么，此时就要用到这个插槽

子组件当中`<slot></slot>`其实就是占位用的，让父组件给它填充内容，可以带标签（这个slot其实就是插槽，本质上是一个组件标签）

!!! 分类

* 具名插槽
* 默认插槽
* 作用域插槽

!!! 使用

子组件的slot可以通过 属性传递值给父组件，然后父组件可以根据不同需求改变这个slot内部的显示结构，把子组件的值，传给父组件固定的区域进行操作

!!! 注意

父组件的数据是给子组件展示的，子组件展示过程当中，数据的结构由父组件决定的。

!!! 默认插槽和具名插槽实例

子组件

```html
<template>
  <div id="app">
    <h2>相同的部分</h2>
	<!--插槽：留一个坑，等到使用的时候来填这个坑。-->
      <!--使用就是说实例化这个子组件对象，就是写这个组件对象的组件标签的时候，而这个子组件
其实是在其父组件当中使用的-->
      
    <!--这是默认插槽：slot标签中可以写内容，如果父组件使用插槽的时候传递了内容，渲染的是传
递过来的内容。如果父组件没有传递内容，渲染的是slot标签中默认的内容-->
    <!--一个组件当中只能有一个默认插槽-->
	<slot>
        默认内容
    </slot>
      
    <!--具名插槽：带name属性的插槽-->
    <slot name="st">
      	默认内容
    </slot>
      
    <!--作用域插槽-->
    <ul>
        <li v-for="(todo,index) in todos" :key="todo.id">
            <!--回传数据给父组件：这类的语法类似于props（但其实并不是），props是父向子传
递，这里是需要子组件把数据回传给父组件，由父组件为其添加结构和样式-->
            <slot name="slotScope" :todo="todo">
                {{todo.content}}
            </slot>
        </li>
    </ul>
    
      <slot></slot>
      
    
  </div>
</template>
<script>
export default {
  name: "Child",
  props:["todos"]
</script>

<style scoped>
/style>
```

父组件

```html
<template>
  <div id="app">
      
    <!--填充默认插槽-->
      <!--一个template（模板）对应一个插槽，这个模板的内容会被用来填充到子组件的插槽中去，
插槽的内容可以是html结构或者css样式-->
      <!--给不同的插槽传递内容需要写不同的template-->
 
    <!--使用子组件-->
	<Child>
      <template>
      	<p>第一次使用子组件时填充的内容</p>
      </template>
    </Child>
	
	<!--使用子组件-->
	<Child>
      <!--填充默认插槽-->
      <template>
      	<!--两次使用子组件时给默认插槽传递了不同的内容-->
      	<h1>第二次使用子组件时填充的内容</h1>
      </template>
	</Child>

<!--分割线-->

     <!--填充具名插槽-->
     <!--使用子组件-->
     <Child>
       <!--通过slot属性和子组件的具名插槽进行对应，两个值相同时会联系在一起，插槽的内容就会传过去-->
       <template slot="st">
         <p>给具名插槽st传递的内容一</p>
       </template>
     </Child>

    <!--使用子组件-->
    <Child>
    <!--填充具名插槽-->
      <template>
      <!--两次使用子组件时给具名插槽传递了不同的内容-->
      	<h1>给具名插槽st传递的内容二</h1>
      </template>
    </Child>

<!--分割线-->
     <!--作用域插槽：三句话
		1.数组在父组件当中
		2.数据需要传递给子组件遍历展示（其实就是v-for）
		3.子组件在使用数据的时候，数据的结构和样式子组件说了不算，由使用它的父组件说了算
	-->
            
     <Child :todos="todos">
       <!--slot-scope接收子组件作用域插槽中回传的数据，把回传的数据封装在一个对象里面（切记
这是一个对象，要通过它去拿回传过来的数据进行操作，作用域插槽在elementUI里用的非常多）
         slotScope:{
             todo,
         }
         -->
       <!--<template slot-scope="slotScope">-->
       <!--因为回传过来的数据是一个如上所示的对象，所以这里可以使用解构的语法直接拿到其中的数
据，从而简化操作-->
       <!--作用域插槽是特殊的具名插槽，仍然需要使用slot属性与对应的插槽进行联系（能够回传数
据的具名插槽就是作用域插槽）-->
       <template slot-scope="{todo}" slot="slotScope">
         <!--父组件对回传的数据添加结构和样式，然后再传递给子组件去使用-->
         <span :class={color:todo.isOver?'red':'green'}>{{todo.content}}</span>
       </template>
     </Child>
  </div>
</template>

<script>
import Child from "./components/Child";//父组件引入子组件
export default {
  name: "App",
  components: {
	Child//注册子组件
  },
  data(){
      return {
		todos:[
            {id:1,content:"抽烟",isOver:true},
            {id:2,content:"喝酒",isOver:false},
            {id:3,content:"烫头",isOver:true}
        ]
      }
  }
</script>

<style scoped>
/style>
```

!!! 疑惑

在一个子组件Child标签内，给一个插槽通过多个template传递内容时，所传递的内容会依次渲染在页面上，并不会覆盖，也就是说，template是可以多次使用的。

!!! 总结

具名插槽和默认插槽是父向子传递数据，作用域插槽是父子之间传递数据
